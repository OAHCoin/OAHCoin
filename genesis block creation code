// If genesis block hash does not match, then generate new genesis hash.
	
    if (block.GetHash() != hashGenesisBlock)
    {
	printf("Searching for genesis block...\n");
	        // This will figure out a valid hash and Nonce if you're
        // creating a different genesis block:
        uint256 hashTarget = CBigNum().SetCompact(block.nBits).getuint256();
        uint256 thash;

        while(true)
        {
            thash = block.GetHash();
            if (thash <= hashTarget)
                break;
            if ((block.nNonce & 0xFFF) == 0)
            {
                printf("nonce %08X: hash = %s (target = %s)\n", block.nNonce, thash.ToString().c_str(), hashTarget.ToString().c_str());
            }
            ++block.nNonce;
            if (block.nNonce == 0)
            {
                printf("NONCE WRAPPED, incrementing time\n");
                ++block.nTime;
            }
        }
        printf("block.nTime = %u \n", block.nTime);
        printf("block.nNonce = %u \n", block.nNonce);
        printf("block.GetHash = %s\n", block.GetHash().ToString().c_str());
	printf("block.hashMerkleRoot == %s\n", block.hashMerkleRoot.ToString().c_str());
  }

//after updating hash nnonce and merkleroot and compile, change following function to output new checksum
if (!CheckStakeModifierCheckpoints(pindexNew->nHeight, pindexNew->nStakeModifierChecksum))
        //return error("AddToBlockIndex() : Rejected by stake modifier checkpoint height=%d, modifier=0x%016"PRI64x, pindexNew->nHeight, nStakeModifier
	return error("AddToBlockIndex() : Rejected by stake modifier checkpoint height=%d, modifier=0x%016"PRI64x" pindexNew->nStakeModifierChecksum=0x%08"PRI64x, pindexNew->nHeight, nStakeModifier, pindexNew->nStakeModifierChecksum);

//compile and run
//now check debug.log for new checksum from file above and update to kernel.cpp checksum 0
//compile again
